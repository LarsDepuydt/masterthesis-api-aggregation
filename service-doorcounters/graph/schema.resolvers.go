package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"time"

	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-doorcounters/graph/data"
	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-doorcounters/graph/model"
)

// Entrances is the resolver for the entrances field.
func (r *buildingResolver) Entrances(ctx context.Context, obj *model.Building) ([]*model.Entrance, error) {
	// Check if this is our specific building
	if obj.ID != "TMV25" {
		return nil, fmt.Errorf("Entrences for buildings other then 'Thomas Manns Vej 25' are not implemented")
	}

	// Return all entrances from our static data
	return data.StaticEntrances, nil
}

// TelemetryData is the resolver for the telemetryData field.
func (r *entranceResolver) TelemetryData(ctx context.Context, obj *model.Entrance, startTime time.Time, endTime *time.Time) ([]*model.TelemetryData, error) {
	// Convert times to milliseconds
	startTs := startTime.Unix() * 1000
	var endTs int64
	if endTime != nil {
		endTs = endTime.Unix() * 1000
	} else {
		endTs = time.Now().Unix() * 1000
	}

	// Fetch raw telemetry data
	data, err := FetchTelemetryData(startTs, endTs)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL format with door-specific values
	var result []*model.TelemetryData
	for _, d := range data {
		var value *int32

		// Select value based on entrance ID
		switch obj.ID {
		case "a":
			value = d.DoorA
		case "b":
			value = d.DoorB
		case "c":
			value = d.DoorC
		default:
			return nil, fmt.Errorf("unknown entrance ID: %s", obj.ID)
		}

		result = append(result, &model.TelemetryData{
			Timestamp: time.Unix(d.Timestamp/1000, 0).Format(time.RFC3339),
			Value:     value,
		})
	}

	return result, nil
}

// GetEntrances is the resolver for the getEntrances field.
func (r *queryResolver) GetEntrances(ctx context.Context, ids []string) ([]*model.Entrance, error) {
	if len(ids) == 0 {
		return data.StaticEntrances, nil
	}

	// Create a set for faster lookups
	idSet := make(map[string]bool)
	for _, id := range ids {
		idSet[id] = true
	}

	// Filter entrances based on IDs
	filtered := make([]*model.Entrance, 0)
	for _, entrance := range data.StaticEntrances {
		if idSet[entrance.ID] {
			filtered = append(filtered, entrance)
		}
	}

	return filtered, nil
}

// Building returns BuildingResolver implementation.
func (r *Resolver) Building() BuildingResolver { return &buildingResolver{r} }

// Entrance returns EntranceResolver implementation.
func (r *Resolver) Entrance() EntranceResolver { return &entranceResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type buildingResolver struct{ *Resolver }
type entranceResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
