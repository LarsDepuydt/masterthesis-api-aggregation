package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"encoding/json"
	"fmt"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-BMS/graph/model"
)

// / Sensors is the resolver for the sensors field.
func (r *queryResolver) Sensors(ctx context.Context, ids []string) ([]*model.Sensor, error) {
	metadata, err := r.FetchMetaData()
	if err != nil {
		return nil, err
	}

	var sensors []*model.Sensor
	for _, m := range metadata {
		sensorID := strconv.Itoa(int(m.ExternalID))

		// Filter by IDs if specified
		if ids != nil && !slices.Contains(ids, sensorID) {
			continue
		}

		sensors = append(sensors, &model.Sensor{
			ExternalID: sensorID,
			SourcePath: m.Source,
			Unit:       m.Unit,
		})
	}

	return sensors, nil
}

// Sensors is the resolver for the sensors field.
func (r *roomResolver) Sensors(ctx context.Context, obj *model.Room, ids []string, federationRequires map[string]any) ([]*model.Sensor, error) {
	roomNumber, ok := federationRequires["roomNumber"].(string)
	if !ok {
		return nil, fmt.Errorf("missing required room number")
	}

	metadata, err := r.FetchMetaData()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch metadata: %v", err)
	}

	requestedIDsMap := make(map[string]struct{})
	if ids != nil {
		for _, id := range ids {
			requestedIDsMap[id] = struct{}{}
		}
	}

	var sensors []*model.Sensor
	for _, m := range metadata {
		// Extract the room identifier from the path
		extractedRoomIdentifier := ""
		if strings.Contains(m.Source, "=IBI") {
			parts := strings.Split(m.Source, "=IBI")
			if len(parts) > 0 {
				beforeIBI := parts[0] // Everything before "=IBI"
				lastSlashIndex := strings.LastIndex(beforeIBI, "/")
				if lastSlashIndex != -1 {
					lastSegment := beforeIBI[lastSlashIndex+1:] // e.g., TM025_1_20_A.001e

					lastUnderscore := strings.LastIndex(lastSegment, "_")
					if lastUnderscore != -1 && lastUnderscore+1 < len(lastSegment) {
						extractedRoomIdentifier = lastSegment[lastUnderscore+1:] // e.g., A.001e
					}
				}
			}
		}

		// Match exactly
		if extractedRoomIdentifier != roomNumber {
			continue
		}

		sensorID := strconv.Itoa(int(m.ExternalID))
		if ids != nil {
			if _, found := requestedIDsMap[sensorID]; !found {
				continue
			}
		}

		sensors = append(sensors, &model.Sensor{
			ExternalID: sensorID,
			SourcePath: m.Source,
			Unit:       m.Unit,
		})
	}

	return sensors, nil
}

// Values is the resolver for the values field.
func (r *sensorResolver) Values(ctx context.Context, obj *model.Sensor, startTime time.Time, endTime *time.Time) ([]*model.Value, error) {
	var endTimeDefined time.Time
	if endTime != nil {
		endTimeDefined = *endTime
	} else {
		endTimeDefined = time.Now().UTC()
	}

	url := fmt.Sprintf("https://bms-api.build.aau.dk/api/v1/trenddata?externallogid=%s&starttime=%s&endtime=%s",
		obj.ExternalID,
		startTime.Format(time.RFC3339),
		endTimeDefined.Format(time.RFC3339),
	)
	body, err := SendRequest(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch trend data: %v", err)
	}

	var trendData []TrendDataResponse
	if err := json.Unmarshal(body, &trendData); err != nil {
		return nil, fmt.Errorf("failed to parse trend data JSON: %v", err)
	}

	// Convert timestamps and map to Value struct
	var values []*model.Value
	for _, data := range trendData {
		t, err := time.Parse("2006-01-02 15:04:05", data.Timestamp)
		if err != nil {
			return nil, fmt.Errorf("failed to convert timestamp: %v", err)
		}

		values = append(values, &model.Value{
			Timestamp: t,
			Value:     data.Value,
		})
	}

	return values, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Room returns RoomResolver implementation.
func (r *Resolver) Room() RoomResolver { return &roomResolver{r} }

// Sensor returns SensorResolver implementation.
func (r *Resolver) Sensor() SensorResolver { return &sensorResolver{r} }

type queryResolver struct{ *Resolver }
type roomResolver struct{ *Resolver }
type sensorResolver struct{ *Resolver }
