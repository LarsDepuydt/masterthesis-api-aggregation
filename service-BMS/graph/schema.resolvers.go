package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"encoding/json"
	"fmt"
	"slices"
	"time"

	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-BMS/graph/model"
)

// / Sensors is the resolver for the sensors field.
func (r *queryResolver) Sensors(ctx context.Context, ids []string) ([]*model.Sensor, error) {
	// Fetch metadata
	metadata, err := FetchMetaData()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch metadata: %v", err)
	}

	var sensors []*model.Sensor
	for _, meta := range metadata {
		// Convert ExternalID (int32) to string
		externalIDStr := fmt.Sprintf("%d", meta.ExternalID)

		// Only include sensors whose ExternalID matches one of the provided ids
		if len(ids) == 0 || slices.Contains(ids, externalIDStr) {
			// Create the Sensor object
			sensor := &model.Sensor{
				ExternalID: externalIDStr, // Use the string version of ExternalID
				SourcePath: meta.Source,
				Unit:       meta.Unit,
			}
			sensors = append(sensors, sensor)
		}
	}

	return sensors, nil
}

// Values is the resolver for the values field.
func (r *sensorResolver) Values(ctx context.Context, obj *model.Sensor, startTime time.Time, endTime *time.Time) ([]*model.Value, error) {
	var endTimeDefined time.Time
	if endTime != nil {
		endTimeDefined = *endTime
	} else {
		endTimeDefined = time.Now().UTC()
	}

	url := fmt.Sprintf("https://bms-api.build.aau.dk/api/v1/trenddata?externallogid=%s&starttime=%s&endtime=%s",
		obj.ExternalID,
		startTime.Format(time.RFC3339),
		endTimeDefined.Format(time.RFC3339),
	)
	body, err := SendRequest(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch trend data: %v", err)
	}

	var trendData []TrendDataResponse
	if err := json.Unmarshal(body, &trendData); err != nil {
		return nil, fmt.Errorf("failed to parse trend data JSON: %v", err)
	}

	// Convert timestamps and map to Value struct
	var values []*model.Value
	for _, data := range trendData {
		t, err := time.Parse("2006-01-02 15:04:05", data.Timestamp)
		if err != nil {
			return nil, fmt.Errorf("failed to convert timestamp: %v", err)
		}

		values = append(values, &model.Value{
			Timestamp: t,
			Value:     data.Value,
		})
	}

	return values, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Sensor returns SensorResolver implementation.
func (r *Resolver) Sensor() SensorResolver { return &sensorResolver{r} }

type queryResolver struct{ *Resolver }
type sensorResolver struct{ *Resolver }
