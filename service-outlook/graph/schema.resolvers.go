package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"time"

	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-outlook/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// Rooms is the resolver for the rooms field.
func (r *queryResolver) Rooms(ctx context.Context, emails []string) ([]*model.Room, error) {
	collection := r.getCollection()
	if collection == nil {
		return nil, fmt.Errorf("database connection error")
	}

	// Build filter based on provided room emails
	filter := bson.M{}
	if len(emails) > 0 {
		filter["rooms.email"] = bson.M{"$in": emails}
	}

	// Get distinct room emails
	roomEmails, err := collection.Distinct(ctx, "rooms.email", filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get distinct rooms: %v", err)
	}

	var rooms []*model.Room
	for _, email := range roomEmails {
		roomEmail, ok := email.(string)
		if !ok {
			continue
		}

		// Get room details from first matching event
		var event struct {
			Rooms []MongoRoom `bson:"rooms"`
		}

		err := collection.FindOne(
			ctx,
			bson.M{"rooms.email": roomEmail},
			options.FindOne().SetProjection(bson.M{"rooms.$": 1}),
		).Decode(&event)

		if err != nil {
			if err == mongo.ErrNoDocuments {
				continue
			}
			return nil, fmt.Errorf("failed to get room details: %v", err)
		}

		if len(event.Rooms) == 0 {
			continue
		}

		rooms = append(rooms, &model.Room{
			Name:  event.Rooms[0].Name,
			Email: event.Rooms[0].Email,
		})
	}

	return rooms, nil
}

// Events is the resolver for the events field.
func (r *roomResolver) Events(ctx context.Context, obj *model.Room, startTime time.Time, endTime *time.Time) ([]*model.Event, error) {
	collection := r.getCollection()
	if collection == nil {
		return nil, fmt.Errorf("database connection error")
	}

	// Build time filter
	timeFilter := bson.M{"start": bson.M{"$gte": startTime}}
	if endTime != nil {
		timeFilter["end"] = bson.M{"$lte": *endTime}
	}

	// Combine with room filter
	filter := bson.M{
		"$and": []bson.M{
			{"rooms.email": obj.Email},
			timeFilter,
		},
	}

	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("failed to find events: %v", err)
	}
	defer cursor.Close(ctx)

	var mongoEvents []MongoEvent
	if err = cursor.All(ctx, &mongoEvents); err != nil {
		return nil, fmt.Errorf("failed to decode events: %v", err)
	}

	// Convert MongoEvents to GraphQL Events
	var events []*model.Event
	for _, me := range mongoEvents {
		var rooms []*model.Room
		for _, r := range me.Rooms {
			rooms = append(rooms, &model.Room{
				Name:  r.Name,
				Email: r.Email,
			})
		}

		var depts []*model.DepartmentParticipation
		for _, d := range me.DepartmentBreakdown {
			depts = append(depts, &model.DepartmentParticipation{
				Department:    d.Department,
				AttendeeCount: d.AttendeeCount,
				IsExternal:    d.IsExternal,
			})
		}

		events = append(events, &model.Event{
			EventID:             me.EventID,
			Subject:             me.Subject,
			Start:               me.Start.Format(time.RFC3339),
			End:                 me.End.Format(time.RFC3339),
			DurationMinutes:     me.DurationMinutes,
			DepartmentBreakdown: depts,
		})
	}

	return events, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Room returns RoomResolver implementation.
func (r *Resolver) Room() RoomResolver { return &roomResolver{r} }

type queryResolver struct{ *Resolver }
type roomResolver struct{ *Resolver }
