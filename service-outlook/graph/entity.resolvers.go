package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"log"

	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-outlook/graph/data"
	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-outlook/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

// FindRoomByID is the resolver for the findRoomByID field.
func (r *entityResolver) FindRoomByID(ctx context.Context, id string) (*model.Room, error) {
	// 1. Use the hardcoded map to find the email associated with this ID.
	// This is the first lookup and acts as a quick check if Outlook has data for this ID.
	email, ok := data.HardcodedIDToEmailMapData[id] // Access the imported package-level map

	if !ok {
		// If the ID is NOT found in our hardcoded map, it means this Outlook subgraph
		// does not have data for this specific room ID.
		return &model.Room{ID: id}, nil // Return nil Room and nil error for "not found"
	}

	// 2. Get the MongoDB collection.
	collection, err := r.getCollection() // Assuming this method exists and is correct
	if err != nil {
		return nil, fmt.Errorf("database connection error in room entity resolver: %w", err)
	}

	// 3. Build the MongoDB filter using the email found in the map.
	// We are looking for a document that contains a room object with this specific email.
	filter := bson.M{
		"rooms.email": email,
	}

	// 4. Struct to decode the document found by the filter.
	// Matches the structure where rooms are an array within a document.
	var doc struct {
		Rooms []MongoRoom `bson:"rooms"`
		// Include other top-level fields if needed
	}

	// 5. Execute the FindOne query to get the document containing the room by email.
	err = collection.FindOne(ctx, filter).Decode(&doc)

	// 6. Handle query results.
	if err != nil {
		if err == mongo.ErrNoDocuments {
			// This scenario is unexpected if the email *is* in the hardcoded map.
			// It implies a data inconsistency between the map and the database.
			log.Printf("Entity Resolver Error: Email '%s' (from map for ID %s) NOT found in MongoDB.", email, id)
			// Depending on strictness, you might return an error here, but returning nil, nil
			// signals to the gateway that data isn't available from this subgraph.
			return &model.Room{ID: id}, nil
		}
		// Handle other database errors.
		return nil, fmt.Errorf("failed to query database for room email %s: %w", email, err)
	}

	// 7. If a document was found, iterate its 'rooms' array to find the specific MongoRoom object
	// that has the matching email. This is necessary because the filter matched the parent document.
	var foundRoomData *MongoRoom
	for _, mongoRoom := range doc.Rooms {
		if mongoRoom.Email == email { // Match the email from the map lookup
			foundRoomData = &mongoRoom
			break // Found the correct room object in the array
		}
	}

	// 8. Double-check that we actually found the room within the array.
	if foundRoomData == nil {
		// This case should theoretically not happen if FindOne found a document using {"rooms.email": email},
		// but it's a safety check.
		return nil, nil // Treat as not found
	}

	// 9. Populate the GraphQL model.Room struct with data from the found MongoRoom.
	resultRoom := &model.Room{
		ID:    id,                  // Use the original ID requested by the gateway
		Name:  foundRoomData.Name,  // Get Name from the MongoRoom data
		Email: foundRoomData.Email, // Get Email from the MongoRoom data (should match 'email')
	}

	return resultRoom, nil // Return the populated model.Room
}

// Entity returns EntityResolver implementation.
func (r *Resolver) Entity() EntityResolver { return &entityResolver{r} }

type entityResolver struct{ *Resolver }
