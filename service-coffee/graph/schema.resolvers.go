package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-coffee/graph/model"
)

// Machines is the resolver for the machines field.
func (r *floorResolver) Machines(ctx context.Context, obj *model.Floor) ([]*model.Machine, error) {
	if r.DB == nil {
		if err := r.initCofeeDBConnection(); err != nil {
			log.Printf("PostgreSQL init error in Floor.Machines resolver: %v", err)
			return nil, err
		}
	}

	query := `
		SELECT machine_id, machine_name
		FROM machines
		WHERE floor_id = $1
	`
	rows, err := r.DB.QueryContext(ctx, query, obj.ID)
	if err != nil {
		log.Printf("Error querying machines for floor %s: %v", obj.ID, err)
		return nil, fmt.Errorf("error fetching machines for floor: %w", err)
	}
	defer rows.Close()

	var machines []*model.Machine
	for rows.Next() {
		var m model.Machine
		if err := rows.Scan(&m.ID, &m.Name); err != nil {
			log.Printf("Error scanning machine for floor %s: %v", obj.ID, err)
			return nil, fmt.Errorf("error scanning machine: %w", err)
		}
		machines = append(machines, &m)
	}

	return machines, nil
}

// BeverageCounts is the resolver for the beverageCounts field.
func (r *machineResolver) BeverageCounts(ctx context.Context, obj *model.Machine, startTime *time.Time, endTime *time.Time) ([]*model.BeverageCount, error) {
	if obj == nil {
		return nil, fmt.Errorf("cannot fetch beverage counts for a nil machine")
	}

	log.Printf("Resolving BeverageCounts for Machine ID: %s, Start: %v, End: %v", obj.ID, startTime, endTime)

	// Base query for counts
	query := `SELECT id, total_beverages, timestamp FROM beverage_counts WHERE machine_id = $1 AND timestamp >= $2`
	args := []interface{}{obj.ID, startTime}
	paramIdx := 3 // Start next parameter at $3

	// Add endTime condition if provided
	if endTime != nil {
		query += fmt.Sprintf(" AND timestamp <= $%d", paramIdx)
		args = append(args, *endTime)
		paramIdx++
	}

	query += " ORDER BY timestamp DESC"

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		log.Printf("Error querying beverage counts for machine %s: %v", obj.ID, err)
		// Return empty list on error? Or the error? Depending on desired behaviour.
		// Returning error might be better for debugging.
		return nil, fmt.Errorf("database error fetching beverage counts: %w", err)
	}
	defer rows.Close()

	var counts []*model.BeverageCount
	for rows.Next() {
		var bc model.BeverageCount
		var id int64 // Scan DB id into int64 first
		if err := rows.Scan(&id, &bc.TotalBeverages, &bc.Timestamp); err != nil {
			log.Printf("Error scanning beverage count row for machine %s: %v", obj.ID, err)
			return nil, fmt.Errorf("database error scanning beverage count row: %w", err)
		}
		bc.ID = strconv.FormatInt(id, 10) // Convert id to string for GraphQL model
		counts = append(counts, &bc)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating beverage count rows for machine %s: %v", obj.ID, err)
		return nil, fmt.Errorf("database error iterating beverage counts: %w", err)
	}

	// Return empty slice if no results, not nil, as per GraphQL non-null list [BeverageCount!]!
	if counts == nil {
		counts = []*model.BeverageCount{}
	}

	return counts, nil
}

// BeverageDetails is the resolver for the beverageDetails field.
func (r *machineResolver) BeverageDetails(ctx context.Context, obj *model.Machine, startTime *time.Time, endTime *time.Time) ([]*model.BeverageDetail, error) {
	if obj == nil {
		return nil, fmt.Errorf("cannot fetch beverage details for a nil machine")
	}

	// Base query for details
	query := `SELECT id, beverage_name, count, timestamp FROM beverage_details WHERE machine_id = $1 AND timestamp >= $2`
	args := []interface{}{obj.ID, startTime}
	paramIdx := 3 // Start next parameter at $3

	// Add endTime condition if provided
	if endTime != nil {
		query += fmt.Sprintf(" AND timestamp <= $%d", paramIdx)
		args = append(args, *endTime)
		paramIdx++
	}

	query += " ORDER BY timestamp DESC" // Or ASC

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		log.Printf("Error querying beverage details for machine %s: %v", obj.ID, err)
		return nil, fmt.Errorf("database error fetching beverage details: %w", err)
	}
	defer rows.Close()

	var details []*model.BeverageDetail
	for rows.Next() {
		var bd model.BeverageDetail
		var id int64 // Scan DB id into int64
		if err := rows.Scan(&id, &bd.BeverageName, &bd.Count, &bd.Timestamp); err != nil {
			log.Printf("Error scanning beverage detail row for machine %s: %v", obj.ID, err)
			return nil, fmt.Errorf("database error scanning beverage detail row: %w", err)
		}
		bd.ID = strconv.FormatInt(id, 10) // Convert id to string
		details = append(details, &bd)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating beverage detail rows for machine %s: %v", obj.ID, err)
		return nil, fmt.Errorf("database error iterating beverage details: %w", err)
	}

	// Return empty slice if no results, not nil, as per GraphQL non-null list [BeverageDetail!]!
	if details == nil {
		details = []*model.BeverageDetail{}
	}

	return details, nil
}

// Machines is the resolver for the machines field.
func (r *queryResolver) Machines(ctx context.Context, machineIDs []string) ([]*model.Machine, error) {
	// Ensure DB is initialized
	if r.DB == nil {
		if err := r.initCofeeDBConnection(); err != nil {
			log.Printf("PostgreSQL initialization error: %v", err)
			return nil, err
		}
	}

	query := `
		SELECT machine_id, machine_name, floor_id
		FROM machines
	`
	var args []interface{}
	if len(machineIDs) > 0 {
		placeholders := make([]string, len(machineIDs))
		for i, id := range machineIDs {
			placeholders[i] = "$" + strconv.Itoa(i+1)
			args = append(args, id)
		}
		query += fmt.Sprintf(" WHERE machine_id IN (%s)", strings.Join(placeholders, ", "))
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		log.Printf("Error querying machines: %v", err)
		return nil, fmt.Errorf("error fetching machines: %w", err)
	}
	defer rows.Close()

	var machines []*model.Machine
	for rows.Next() {
		var machine model.Machine
		var floorID string // Temporary variable to hold floor_id
		if err := rows.Scan(&machine.ID, &machine.Name, &floorID); err != nil {
			log.Printf("Error scanning machine row: %v", err)
			return nil, fmt.Errorf("error scanning machine: %w", err)
		}
		// We don't directly set machine.FloorID as it shouldn't be a GraphQL field.
		// The floorID is implicitly available within the 'machine' variable for federation.
		machines = append(machines, &machine)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating over machine rows: %v", err)
		return nil, fmt.Errorf("error iterating machines: %w", err)
	}

	return machines, nil
}

// Floor returns FloorResolver implementation.
func (r *Resolver) Floor() FloorResolver { return &floorResolver{r} }

// Machine returns MachineResolver implementation.
func (r *Resolver) Machine() MachineResolver { return &machineResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type floorResolver struct{ *Resolver }
type machineResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
