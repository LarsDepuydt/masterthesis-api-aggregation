package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-coffee/graph/model"
)

// BeverageCounts is the resolver for the beverageCounts field.
func (r *machineResolver) BeverageCounts(ctx context.Context, obj *model.Machine, startTime time.Time, endTime *time.Time) ([]*model.BeverageCount, error) {
	if obj == nil {
		return nil, fmt.Errorf("cannot fetch beverage counts for a nil machine")
	}

	log.Printf("Resolving BeverageCounts for Machine ID: %s, Start: %v, End: %v", obj.MachineID, startTime, endTime)

	// Base query for counts
	query := `SELECT id, total_beverages, timestamp FROM beverage_counts WHERE machine_id = $1 AND timestamp >= $2`
	args := []interface{}{obj.MachineID, startTime}
	paramIdx := 3 // Start next parameter at $3

	// Add endTime condition if provided
	if endTime != nil {
		query += fmt.Sprintf(" AND timestamp <= $%d", paramIdx)
		args = append(args, *endTime)
		paramIdx++
	}

	query += " ORDER BY timestamp DESC"

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		log.Printf("Error querying beverage counts for machine %s: %v", obj.MachineID, err)
		// Return empty list on error? Or the error? Depending on desired behaviour.
		// Returning error might be better for debugging.
		return nil, fmt.Errorf("database error fetching beverage counts: %w", err)
	}
	defer rows.Close()

	var counts []*model.BeverageCount
	for rows.Next() {
		var bc model.BeverageCount
		var id int64 // Scan DB id into int64 first
		if err := rows.Scan(&id, &bc.TotalBeverages, &bc.Timestamp); err != nil {
			log.Printf("Error scanning beverage count row for machine %s: %v", obj.MachineID, err)
			return nil, fmt.Errorf("database error scanning beverage count row: %w", err)
		}
		bc.ID = strconv.FormatInt(id, 10) // Convert id to string for GraphQL model
		counts = append(counts, &bc)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating beverage count rows for machine %s: %v", obj.MachineID, err)
		return nil, fmt.Errorf("database error iterating beverage counts: %w", err)
	}

	// Return empty slice if no results, not nil, as per GraphQL non-null list [BeverageCount!]!
	if counts == nil {
		counts = []*model.BeverageCount{}
	}

	return counts, nil
}

// BeverageDetails is the resolver for the beverageDetails field.
func (r *machineResolver) BeverageDetails(ctx context.Context, obj *model.Machine, startTime time.Time, endTime *time.Time) ([]*model.BeverageDetail, error) {
	if obj == nil {
		return nil, fmt.Errorf("cannot fetch beverage details for a nil machine")
	}

	log.Printf("Resolving BeverageDetails for Machine ID: %s, Start: %v, End: %v", obj.MachineID, startTime, endTime)

	// Base query for details
	query := `SELECT id, beverage_name, count, timestamp FROM beverage_details WHERE machine_id = $1 AND timestamp >= $2`
	args := []interface{}{obj.MachineID, startTime}
	paramIdx := 3 // Start next parameter at $3

	// Add endTime condition if provided
	if endTime != nil {
		query += fmt.Sprintf(" AND timestamp <= $%d", paramIdx)
		args = append(args, *endTime)
		paramIdx++
	}

	query += " ORDER BY timestamp DESC" // Or ASC

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		log.Printf("Error querying beverage details for machine %s: %v", obj.MachineID, err)
		return nil, fmt.Errorf("database error fetching beverage details: %w", err)
	}
	defer rows.Close()

	var details []*model.BeverageDetail
	for rows.Next() {
		var bd model.BeverageDetail
		var id int64 // Scan DB id into int64
		if err := rows.Scan(&id, &bd.BeverageName, &bd.Count, &bd.Timestamp); err != nil {
			log.Printf("Error scanning beverage detail row for machine %s: %v", obj.MachineID, err)
			return nil, fmt.Errorf("database error scanning beverage detail row: %w", err)
		}
		bd.ID = strconv.FormatInt(id, 10) // Convert id to string
		details = append(details, &bd)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating beverage detail rows for machine %s: %v", obj.MachineID, err)
		return nil, fmt.Errorf("database error iterating beverage details: %w", err)
	}

	// Return empty slice if no results, not nil, as per GraphQL non-null list [BeverageDetail!]!
	if details == nil {
		details = []*model.BeverageDetail{}
	}

	return details, nil
}

// GetMachine is the resolver for the getMachine field.
func (r *queryResolver) GetMachine(ctx context.Context, machineIds []string) ([]*model.Machine, error) {
	// Ensure DB is initialized (ideally once at startup)
	if err := r.initCofeeDBConnection(); err != nil {
		log.Printf("PostgreSQL initialization error: %v", err)
		return nil, err
	}

	// Base query selects only machine columns
	query := `SELECT m.machine_id, m.machine_name FROM machines m`
	var args []interface{}
	var conditions []string

	// Add WHERE clause if machineIds are provided
	if len(machineIds) > 0 {
		placeholders := make([]string, len(machineIds))
		for i, id := range machineIds {
			placeholders[i] = "$" + strconv.Itoa(i+1) // Parameters start at $1
			args = append(args, id)
		}
		conditions = append(conditions, fmt.Sprintf("m.machine_id IN (%s)", strings.Join(placeholders, ", ")))
	}

	if len(conditions) > 0 {
		query += " WHERE " + strings.Join(conditions, " AND ")
	}
	query += " ORDER BY m.machine_name" // Optional ordering

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		log.Printf("Error querying machines: %v", err)
		return nil, err
	}
	defer rows.Close()

	var machines []*model.Machine
	for rows.Next() {
		var machine model.Machine
		if err := rows.Scan(&machine.MachineID, &machine.MachineName); err != nil {
			log.Printf("Error scanning machine row: %v", err)
			return nil, err
		}
		// Note: BeverageCounts and BeverageDetails are initially nil/empty.
		// They will be populated by their respective resolvers if requested in the query.
		machines = append(machines, &machine)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating over machine rows: %v", err)
		return nil, err
	}

	// If no machines found for specific IDs, return empty list, not error
	if machines == nil {
		machines = []*model.Machine{}
	}

	return machines, nil
}

// Machine returns MachineResolver implementation.
func (r *Resolver) Machine() MachineResolver { return &machineResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type machineResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
