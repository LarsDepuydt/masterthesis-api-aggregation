package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"strconv"

	"github.com/LarsDepuydt/masterthesis-api-aggregation/service-coffee/graph/model"
)

// GetMachine is the resolver for the getMachine field.
func (r *queryResolver) GetMachine(ctx context.Context, machineIds []string) ([]*model.Machine, error) {
	if err := r.initCofeeDBConnection(); err != nil {
		log.Printf("PostgreSQL initialization error: %v", err)
		return nil, err
	}

	query := `
			SELECT
				m.machine_id, m.machine_name,
				bc.id AS count_id, bc.total_beverages, bc.timestamp AS count_timestamp, bc.machine_id AS bc_machine_id,
				bd.id AS detail_id, bd.beverage_name, bd.count AS detail_count, bd.timestamp AS detail_timestamp, bd.machine_id AS bd_machine_id
			FROM machines m
			LEFT JOIN beverage_counts bc ON m.machine_id = bc.machine_id
			LEFT JOIN beverage_details bd ON m.machine_id = bd.machine_id
		`

	var args []interface{}
	if len(machineIds) > 0 {
		placeholders := ""
		args = make([]interface{}, len(machineIds))
		for i, id := range machineIds {
			if i > 0 {
				placeholders += ", "
			}
			placeholders += "$" + strconv.Itoa(i+1)
			args[i] = id
		}
		query += fmt.Sprintf(" WHERE m.machine_id IN (%s)", placeholders)
	}
	// Add ORDER BY to potentially help with processing, although the map handles uniqueness
	query += " ORDER BY m.machine_id, bc.id, bd.id" // Optional but can sometimes help locality

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		log.Printf("Error querying machines with joins: %v", err)
		return nil, err
	}
	defer rows.Close()

	machineMap := make(map[string]*model.Machine)
	// Keep track of added child record IDs *per machine*
	seenCounts := make(map[string]map[int64]bool)  // map[machineID]map[countID] -> true
	seenDetails := make(map[string]map[int64]bool) // map[machineID]map[detailID] -> true

	for rows.Next() {
		var (
			machineID      string
			machineName    string
			countID        sql.NullInt64
			totalBeverages sql.NullInt64
			countTS        sql.NullTime
			bcMachineID    sql.NullString // Can likely remove this if always same as machineID
			detailID       sql.NullInt64
			beverageName   sql.NullString
			detailCount    sql.NullInt64
			detailTS       sql.NullTime
			bdMachineID    sql.NullString // Can likely remove this if always same as machineID
		)

		if err := rows.Scan(
			&machineID, &machineName,
			&countID, &totalBeverages, &countTS, &bcMachineID,
			&detailID, &beverageName, &detailCount, &detailTS, &bdMachineID,
		); err != nil {
			log.Printf("Error scanning joined row: %v", err)
			return nil, err
		}

		// --- Machine Handling ---
		machine, ok := machineMap[machineID]
		if !ok {
			machine = &model.Machine{
				MachineID:       machineID,
				MachineName:     machineName,
				BeverageCounts:  []*model.BeverageCount{},  // Initialize as empty slice
				BeverageDetails: []*model.BeverageDetail{}, // Initialize as empty slice
			}
			machineMap[machineID] = machine
			// Initialize seen maps for this new machine
			seenCounts[machineID] = make(map[int64]bool)
			seenDetails[machineID] = make(map[int64]bool)
		}

		// --- BeverageCount Handling (Deduplicated) ---
		// Check if countID is valid AND we haven't seen this countID for this machine yet
		if countID.Valid && !seenCounts[machineID][countID.Int64] {
			// bcMachineID check might be redundant if the JOIN guarantees it matches m.machine_id
			if bcMachineID.Valid {
				machine.BeverageCounts = append(machine.BeverageCounts, &model.BeverageCount{
					ID: strconv.FormatInt(countID.Int64, 10),
					// Assuming Machine in BeverageCount just needs the ID for linking in GraphQL
					TotalBeverages: int32(totalBeverages.Int64),
					Timestamp:      countTS.Time, // Store the actual time.Time
				})
				// Mark this countID as seen for this machine
				seenCounts[machineID][countID.Int64] = true
			}
		}

		// --- BeverageDetail Handling (Deduplicated) ---
		// Check if detailID is valid AND we haven't seen this detailID for this machine yet
		if detailID.Valid && !seenDetails[machineID][detailID.Int64] {
			// bdMachineID check might be redundant
			if bdMachineID.Valid {
				machine.BeverageDetails = append(machine.BeverageDetails, &model.BeverageDetail{
					ID: strconv.FormatInt(detailID.Int64, 10),
					// Assuming Machine in BeverageDetail just needs the ID
					BeverageName: beverageName.String,
					Count:        int32(detailCount.Int64),
					Timestamp:    detailTS.Time, // Store the actual time.Time
				})
				// Mark this detailID as seen for this machine
				seenDetails[machineID][detailID.Int64] = true
			}
		}
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating over joined rows: %v", err)
		return nil, err
	}

	// Convert map to slice for the result
	result := make([]*model.Machine, 0, len(machineMap))
	for _, m := range machineMap {
		result = append(result, m)
	}

	return result, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
